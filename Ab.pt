import pandas as pd

class DataFrameValidator:
    def __init__(self):
        self.data = None
        self.errors = []

    def load_data(self, data):
        if not isinstance(data, pd.DataFrame):
            raise TypeError("Expected a pandas DataFrame object")
        self.data = data

    def check_column_exists(self, column_name):
        if column_name not in self.data.columns:
            self.errors.append(f"Column '{column_name}' does not exist")

    def check_column_type(self, column_name, expected_type):
        actual_type = self.data[column_name].dtype
        if not pd.api.types.is_dtype_equal(actual_type, expected_type):
            self.errors.append(f"Column '{column_name}' type is {actual_type}, expected {expected_type}")

    def check_column_not_null(self, column_name):
        if self.data[column_name].isnull().any():
            self.errors.append(f"Column '{column_name}' contains null values")

    def validate(self):
        self.errors = []  # Clear previous errors
        # Add specific validation checks here
        # Example:
        self.check_column_exists('Name')
        self.check_column_type('Age', int)
        self.check_column_not_null('City')

        if self.errors:
            raise ValidationException(self.errors)

# Custom exception for validation errors
class ValidationException(Exception):
    def __init__(self, errors):
        self.errors = errors

    def __str__(self):
        return f"DataFrame validation errors: {', '.join(self.errors)}"


# Example usage:
# Assuming df is your pandas DataFrame
df = pd.DataFrame({
    'Name': ['Alice', 'Bob', 'Charlie'],
    'Age': [25, 30, 35],
    'City': ['New York', None, 'Los Angeles']
})

validator = DataFrameValidator()

# Load data into the validator
validator.load_data(df)

# Validate the DataFrame
try:
    validator.validate()
    print("DataFrame is valid!")
except ValidationException as ve:
    print(f"Validation failed: {ve}")
